declare lower;
declare real_size;

#include_once "../lib/Chart.think"
#include_once "../lib/Value.think"
#include_once "../lib/Oscillate.think"
#include_once "../lib/Smooth.think"
#include_once "../lib/Periods.think"
#include_once "../lib/ZScore.think"

### INPUTS ###
    input TickerOne = "";
    input TickerTwo = "SPY";

    input Quote = {
        default "Close",
        "Open",
        "High",
        "Low",
        "HL2",
        "HLC3",
        "OHLC4",
        "VWAP",
        "RTH",
        "ETH"
    };

    input Mode = {
        default "Combined",
        "Separate",
        "Cloud"
    };

    input Method = {
        default "Logarithmic",
        "ZScored",
        "Absolute"
    };

    input Display = {
        default "Sum",
        "Correlation",
        "Tick"
    };

    input Period = {
        default "Chart",
        "Daily",
        "Weekly",
        "Monthly",
        "MonthlyOPEX",
        "Quarterly",
        "QuarterlyOPEX",
        "Earnings",
        "Yearly",
        "CandlesAgo",
        "SinceDate"
    };

    @Date input SinceDate = 20250407;
    input CandlesAgo      = 252;
    input Separators      = yes;
    input Sanitize        = no;
    input Oscillation     = 0;
    input Smoothing       = 0;
    input Length          = 60;
###

### LOOKUPS ###
    def type;
    switch (Quote) {
        case "Open"  : type = FundamentalType.OPEN;
        case "High"  : type = FundamentalType.HIGH;
        case "Low"   : type = FundamentalType.LOW;
        case "HL2"   : type = FundamentalType.HL2;
        case "HLC3"  : type = FundamentalType.HLC3;
        case "OHLC4" : type = FundamentalType.OHLC4;
        case "VWAP"  : type = FundamentalType.VWAP;
        default      : type = FundamentalType.CLOSE;
    }

    def rawOpenOne;
    def rawOpenTwo;
    def rawCloseOne;
    def rawCloseTwo;
    if TickerOne != "" {
        rawOpenOne  = open(TickerOne);
        rawOpenTwo  = open(TickerTwo);
        rawCloseOne = Fundamental(type, TickerOne);
        rawCloseTwo = Fundamental(type, TickerTwo);
    }
    else {
        rawOpenOne  = open;
        rawOpenTwo  = open(TickerTwo);
        rawCloseOne = Fundamental(type);
        rawCloseTwo = Fundamental(type, TickerTwo);
    }

    # Sanitize
    def dataOpenOne;
    def dataOpenTwo;
    def dataCloseOne;
    def dataCloseTwo;
    if Sanitize {
        dataOpenOne  = Value(rawOpenOne);
        dataOpenTwo  = Value(rawOpenTwo);
        dataCloseOne = Value(rawCloseOne);
        dataCloseTwo = Value(rawCloseTwo);
    }
    else {
        dataOpenOne  = rawOpenOne;
        dataOpenTwo  = rawOpenTwo;
        dataCloseOne = rawCloseOne;
        dataCloseTwo = rawCloseTwo;
    }
###

### CALCULATIONS ###
    def isNewPeriod    = Periods(Period, SinceDate, CandlesAgo).isNewAndValid;
    def isActivePeriod = Periods(Period, SinceDate, CandlesAgo).isActive;

    # Logarithmic
    def logOpenOne;
    def logOpenTwo;
    def logCloseOne;
    def logCloseTwo;
    if Method == Method.Absolute {
        logOpenOne  = dataOpenOne;
        logOpenTwo  = dataOpenTwo;
        logCloseOne = dataCloseOne;
        logCloseTwo = dataCloseTwo;
    }
    else {
        logOpenOne  = If(dataOpenOne  > 0, Log(dataOpenOne),  0);
        logOpenTwo  = If(dataOpenTwo  > 0, Log(dataOpenTwo),  0);
        logCloseOne = If(dataCloseOne > 0, Log(dataCloseOne), 0);
        logCloseTwo = If(dataCloseTwo > 0, Log(dataCloseTwo), 0);
    }

    def rawTickOne;
    def rawTickTwo;
    if Quote == Quote.RTH and !Chart().isRTH {
        rawTickOne = 0;
        rawTickTwo = 0;
    }
    else if Quote == Quote.RTH and !Chart().isIntrabar {
        rawTickOne = logCloseOne - logOpenOne;
        rawTickTwo = logCloseTwo - logOpenTwo;
    }
    else if Quote == Quote.ETH and Chart().isRTH and !Chart().isIntrabar {
        rawTickOne = CompoundValue(1, logOpenOne - logCloseOne[1], 0);
        rawTickTwo = CompoundValue(1, logOpenTwo - logCloseTwo[1], 0);
    }
    else if Quote == Quote.ETH and Chart().isRTH {
        rawTickOne = 0;
        rawTickTwo = 0;
    }
    else {
        rawTickOne = CompoundValue(1, logCloseOne - logCloseOne[1], logCloseOne - logOpenOne);
        rawTickTwo = CompoundValue(1, logCloseTwo - logCloseTwo[1], logCloseTwo - logOpenTwo);
    }

    # Tick
    def zTickOne;
    def zTickTwo;
    def zTick;
    if Method == Method.ZScored {
        zTickOne = ZScore(rawTickOne, Length);
        zTickTwo = ZScore(rawTickTwo, Length);
        zTick    = zTickOne - zTickTwo;
    }
    else {
        zTickOne = rawTickOne;
        zTickTwo = rawTickTwo;
        zTick    = zTickOne - zTickTwo;
    }

    def rawCorr;
    if Display == Display.Correlation {
        rawCorr = Correlation(zTickOne, zTickTwo, Length);
    }
    else {
        rawCorr = 0;
    }

    # Cumulative
    def rawSumOne;
    def rawSumTwo;
    def rawSum;
    if IsNaN(zTick) {
        rawSumOne = GetValue(rawSumOne, 1);
        rawSumTwo = GetValue(rawSumTwo, 1);
        rawSum    = GetValue(rawSum, 1);
    }
    else if isNewPeriod {
        rawSumOne = zTickOne;
        rawSumTwo = zTickTwo;
        rawSum    = zTick;
    }
    else {
        rawSumOne = GetValue(rawSumOne, 1) + zTickOne;
        rawSumTwo = GetValue(rawSumTwo, 1) + zTickTwo;
        rawSum    = GetValue(rawSum, 1)    + zTick;
    }

    # Filters
    def sumOne;
    def sumTwo;
    def sum;
    def tick;
    def corr;
    if !Chart().isValidBar or !isActivePeriod or IsNaN(zTick) {
        sumOne  = Double.NaN;
        sumTwo  = Double.NaN;
        sum     = Double.NaN;
        tick    = Double.NaN;
        corr    = Double.NaN;
    }
    else {
        sumOne  = Smooth(Oscillate(rawSumOne, Oscillation), Smoothing);
        sumTwo  = Smooth(Oscillate(rawSumTwo, Oscillation), Smoothing);
        sum     = Smooth(Oscillate(rawSum,    Oscillation), Smoothing);
        tick    = Smooth(Oscillate(zTick,     Oscillation), Smoothing);
        corr    = Smooth(Oscillate(rawCorr,   Oscillation), Smoothing);
    }
###

### PLOTS ###
    DefineGlobalColor("Line",       CreateColor(48, 48, 48));
    DefineGlobalColor("Separator",  CreateColor(32, 32, 32));
    DefineGlobalColor("Background", CreateColor(12, 12, 12));

    # Tick
    plot T = tick;
    T.SetHiding(Display != Display.Tick);
    T.SetPaintingStrategy(PaintingStrategy.HISTOGRAM);
    T.DefineColor("Up", Color.UPTICK);
    T.DefineColor("Down", Color.DOWNTICK);
    T.DefineColor("Neutral", Color.DARK_GRAY);
    T.SetDefaultColor(T.Color("Neutral"));
    T.AssignValueColor(
        if Separators and isNewPeriod and GetValue(isActivePeriod, 1)
            then GlobalColor("Background")
        else if tick > 0
            then T.Color("Up")
        else if tick < 0
            then T.Color("Down")
            else T.Color("Neutral")
    );

    # Correlation
    plot C = corr;
    C.SetHiding(Display != Display.Correlation);
    C.DefineColor("Up", Color.UPTICK);
    C.DefineColor("Down", Color.DOWNTICK);
    C.DefineColor("Neutral", Color.DARK_GRAY);
    C.SetDefaultColor(C.Color("Neutral"));
    C.AssignValueColor(
        if Separators and isNewPeriod and GetValue(isActivePeriod, 1)
            then GlobalColor("Background")
        else if corr > 0
            then C.Color("Up")
        else if corr < 0
            then C.Color("Down")
            else C.Color("Neutral")
    );

    # Cumulative
    plot S = sum;
    S.SetHiding(Display != Display.Sum or Mode != Mode.Combined);
    S.DefineColor("Up", Color.UPTICK);
    S.DefineColor("Down", Color.DOWNTICK);
    S.DefineColor("Neutral", Color.DARK_GRAY);
    S.SetDefaultColor(S.Color("Neutral"));
    S.AssignValueColor(
        if Separators and isNewPeriod and GetValue(isActivePeriod, 1)
            then GlobalColor("Background")
        else if sum > 0
            then S.Color("Up")
        else if sum < 0
            then S.Color("Down")
            else S.Color("Neutral")
    );

    # Cumulative One
    plot One = sumOne;
    One.SetHiding(Display != Display.Sum or Mode == Mode.Combined);
    One.DefineColor("Value", Color.UPTICK);
    One.SetDefaultColor(One.Color("Value"));
    One.AssignValueColor(
        if Separators and isNewPeriod and GetValue(isActivePeriod, 1)
            then GlobalColor("Background")
            else One.Color("Value")
    );

    # Cumulative Two
    plot Two = sumTwo;
    Two.SetHiding(Display != Display.Sum or Mode == Mode.Combined);
    Two.DefineColor("Value", Color.DOWNTICK);
    Two.SetDefaultColor(Two.Color("Value"));
    Two.AssignValueColor(
        if Separators and isNewPeriod and GetValue(isActivePeriod, 1)
            then GlobalColor("Background")
            else Two.Color("Value")
    );

    # Cloud
    def cloudOne = sumTwo;
    def cloudTwo = sumOne;
    AddCloud(
        data1 = if Mode == Mode.Cloud and Display == Display.Sum
            then cloudOne
            else Double.NaN,
        data2 = if Mode == Mode.Cloud and Display == Display.Sum
            then cloudTwo
            else Double.NaN,
        color1 = One.Color("Value"),
        color2 = Two.Color("Value")
    );

    # Line
    plot N = 0;
    N.SetDefaultColor(GlobalColor("Line"));
    N.HideBubble();
    N.HideTitle();
    N.Hide();

    # Separators
    AddVerticalLine(
        visible = Separators and isNewPeriod and GetValue(isActivePeriod, 1),
        color   = GlobalColor("Separator"),
        stroke  = Curve.SHORT_DASH,
        text    = ""
    );
###
