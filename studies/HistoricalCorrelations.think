declare lower;


### SCRIPTS ###
    script Date {
        def yyyymmdd = GetYYYYMMDD();
        def yyyy     = GetYear();
        def mm       = GetMonth();
        def doy      = GetDay();
        def dom      = GetDayOfMonth(yyyymmdd);
        def dow      = GetDayOfWeek(yyyymmdd);
        def dowj1    = GetDayOfWeek(yyyy * 10000 + 0101);
        def ww       = GetWeek();
        def q        = Ceil(mm / 3);
        def yyyyq    = yyyy * 10 + q;
        def yyyymm   = yyyy * 100 + mm;

        def minus = if yyyy > yyyy[1] and ww >= ww[1] then 1
            else if ww != ww[1] then 0
            else minus[1];

        def yyyyww = (yyyy - minus) * 100 + ww;

        def isAfterOpex    = (dom - 14 - if dow > 5 then dow - 5 else dow + 2) > 0;
        def isEndOfQuarter = mm % 3 == 0;

        def qOpex = if q + isAfterOpex * isEndOfQuarter <= 4
            then q + isAfterOpex * isEndOfQuarter
            else 1;

        def mmOpex = if mm + isAfterOpex <= 12
            then mm + isAfterOpex
            else 1;

        def yyyyOpex = if mm + isAfterOpex <= 12
            then yyyy
            else yyyy + 1;

        def yyyyqOpex  = yyyyOpex * 10  + qOpex;
        def yyyymmOpex = yyyyOpex * 100 + mmOpex;

        def lastEarnings = if HasEarnings(EarningTime.BEFORE_MARKET) or HasEarnings(EarningTime.AFTER_MARKET)[1]
            then GetYYYYMMDD()
            else lastEarnings[1];

        plot P = yyyymmdd;
        P.hide();
    }

    script Chart {
        input Validator = "$DJI";

        def aggregation   = GetAggregationPeriod();
        def isIntraday    = aggregation <  AggregationPeriod.DAY;
        def isDaily       = aggregation == AggregationPeriod.DAY;
        def isMultiDay    = aggregation >  AggregationPeriod.DAY;
        def isIntradayBar = isIntraday and Date() == Date()[1];
        def number        = BarNumber();
        def startBar      = First(number);
        def endBar        = HighestAll(number * !IsNaN(close(Validator)));
        def isValidBar    = number between startBar and endBar;
        def startOffset   = number - startBar;
        def endOffset     = number - endBar;
        def isStart       = number == startBar;
        def isEnd         = number == endBar;

        plot P = Double.NaN;
        P.hide();
    }

    script Value {
        input raw    = 0;
        input minRaw = 0;
        input maxRaw = 0;

        def minValue = if minRaw < 0 then minRaw else -999999999999999;
        def maxValue = if maxRaw > 0 then maxRaw else  999999999999999;

        def isValid;
        if IsNaN(raw) or IsInfinite(raw) {
            isValid = no;
        }
        else {
            isValid = raw between minValue and maxValue;
        }

        def value = if isValid or !Chart().isValidBar
            then raw
            else value[1];

        plot P = value;
        P.hide();
    }

    script Filters {
        input raw         = 0;
        input oscillation = 0;
        input smoothing   = 0;

        def oscValue;
        if oscillation > 1 {
            oscValue = raw - Average(raw, oscillation);
        }
        else {
            oscValue = raw;
        }

        def value;
        if smoothing > 1 {
            value = Inertia(oscValue, smoothing);
        }
        else {
            value = oscValue;
        }

        plot P = value;
        P.Hide();
    }

    script Periods {
        input period  = "Chart";
        input since   = 20250407;
        input candles = 100;

        def isStart     = Chart().isStart;
        def endBar      = Chart().endBar;
        def aggregation = GetAggregationPeriod();

        def isNew;
        if period == "Daily" and aggregation <= AggregationPeriod.FOUR_HOURS {
            isNew = isStart or Date() != Date()[1];
        }
        else if period == "Weekly" and aggregation <= AggregationPeriod.TWO_DAYS {
            isNew = isStart or Date().yyyyww != Date().yyyyww[1];
        }
        else if period == "Monthly" and aggregation <= AggregationPeriod.WEEK {
            isNew = isStart or Date().yyyymm != Date().yyyymm[1];
        }
        else if period == "MonthlyOPEX" and aggregation <= AggregationPeriod.WEEK {
            isNew = isStart or Date().yyyymmOpex != Date().yyyymmOpex[1];
        }
        else if period == "Quarterly" and aggregation <= AggregationPeriod.MONTH {
            isNew = isStart or Date().yyyyq != Date().yyyyq[1];
        }
        else if period == "QuarterlyOPEX" and aggregation <= AggregationPeriod.MONTH {
            isNew = isStart or Date().yyyyqOpex != Date().yyyyqOpex[1];
        }
        else if period == "Earnings" and aggregation <= AggregationPeriod.MONTH {
            isNew = isStart or Date().lastEarnings != Date().lastEarnings[1];
        }
        else if period == "Yearly" and aggregation <= AggregationPeriod.QUARTER {
            isNew = isStart or Date().yyyy != Date().yyyy[1];
        }
        else if period == "SinceDate" {
            isNew = Date() >= since and (Date()[1] < since or isStart);
        }
        else if period == "CandlesAgo" {
            isNew = isStart and candles > endBar or BarNumber() + candles == endBar;
        }
        else {
            isNew = isStart;
        }

        def isActive = isNew or isActive[1];

        plot P = isNew;
        P.hide();
    }

    script CompareRecent {
        input Value  = 0;
        input Length = 0;
        input Offset = 0;

        def avg1 = fold i1 = 0 to Length with v1 do
            v1 + GetValue(Value, i1) / Length;

        def avg2 = GetValue(avg1, Offset);

        def avg3 = fold i3 = 0 to Length with v3 do
            v3 + GetValue(Value, i3) * GetValue(Value, i3 + Offset) / Length;

        def std1 = Sqrt((
            fold i4 = 0 to Length with v4 do
                v4 + Sqr(GetValue(Value, i4) - avg1)
        ) / Length);

        def std2 = GetValue(std1, Offset);

        def zscore = if std1 != 0
            then (Value - avg1) / std1
            else 0;

        def zavg1 = fold i6 = 0 to Length with v6 do
            v6 + GetValue(zscore, i6) / Length;

        def zavg2 = GetValue(zavg1, Offset);

        def zavg3 = fold i8 = 0 to Length with v8 do
            v8 + GetValue(zscore, i8) * GetValue(zscore, i8 + Offset) / Length;

        def zstd1 = Sqrt((
            fold i9 = 0 to Length with v9 do
                v9 + Sqr(GetValue(zscore, i9) - zavg1)
        ) / Length);

        def zstd2 = GetValue(zstd1, Offset);

        plot Z = (zavg3 - zavg1 * zavg2) / (zstd1 * zstd2);
        plot L = (avg3 - avg1 * avg2) / (std1 * std2);
    }
###


### INPUTS ###
    input Ticker = "";

    input Quote = {
        default "Close",
        "Open",
        "High",
        "Low",
        "HL2",
        "HLC3",
        "OHLC4",
        "VWAP"
    };

    input Display = {
        default "Lower",
        "Upper",
        "Both"
    };

    input Method = {
        default "Z-Score",
        "Linear",
        "Both",
        "Either"
    };

    input Sanitize      = no;
    input CompareLength = 12;
    input CompareOffset = 0;
    input Threshold     = 0.8;
    input SpikeLength   = 5;
    input BarsAhead     = 5;
    input ShowLabel     = yes;
    input Separators    = yes;
###


### LOOKUPS ###
    def type;
    switch (Quote) {
        case "Open"  : type = FundamentalType.OPEN;
        case "Close" : type = FundamentalType.CLOSE;
        case "High"  : type = FundamentalType.HIGH;
        case "Low"   : type = FundamentalType.LOW;
        case "HL2"   : type = FundamentalType.HL2;
        case "HLC3"  : type = FundamentalType.HLC3;
        case "OHLC4" : type = FundamentalType.OHLC4;
        case "VWAP"  : type = FundamentalType.VWAP;
    }

    def rawData;
    if Ticker != "" {
        rawData = Fundamental(type, Ticker);
    }
    else {
        rawData = Fundamental(type);
    }

    def data;
    if Sanitize {
        data = Value(rawData);
    }
    else {
        data = rawData;
    }
###


### CALCULATIONS ###
    def mostRecentBar = Chart().endBar - CompareOffset;
    def isRecentBar   = BarNumber() <= mostRecentBar and BarNumber() >= mostRecentBar - CompareLength + 1;
    def recentOffset  = BarNumber() - mostRecentBar;
    def isTooEarly    = BarNumber() <= CompareLength;

    def lscore = CompareRecent(data, CompareLength, recentOffset).L;
    def zscore = CompareRecent(data, CompareLength, recentOffset).Z;

    def score;
    switch (Method) {
        case "Z-Score":
            score = Max(zscore, 0);
        case "Linear":
            score = Max(lscore, 0);
        case "Both":
            score = Max(Min(zscore, lscore), 0);
        case "Either":
            score = Max(Max(zscore, lscore), 0);
    }

    def isSpike;
    def lastSpike;
    def spikeCount;
    if isTooEarly or isRecentBar {
        isSpike    = no;
        lastSpike  = lastSpike[1];
        spikeCount = spikeCount[1];
    }
    else if score >= Threshold and GetMaxValueOffset(score, SpikeLength)[-Floor(SpikeLength / 2)] == Floor(SpikeLength / 2) {
        isSpike    = yes;
        lastSpike  = BarNumber();
        spikeCount = spikeCount[1] + 1;
    }
    else {
        isSpike    = no;
        lastSpike  = lastSpike[1];
        spikeCount = spikeCount[1];
    }

    def isBarAhead = lastSpike > 0 and BarNumber() <= lastSpike + BarsAhead;
###


### PLOTS ###
    DefineGlobalColor("Line",      CreateColor(48, 48, 48));
    DefineGlobalColor("Separator", CreateColor(32, 32, 32));
    DefineGlobalColor("Spike",     Color.WHITE);

    plot S = score;
    S.SetHiding(Display == Display.Upper);
    S.SetPaintingStrategy(PaintingStrategy.HISTOGRAM);
    S.DefineColor("Window", CreateColor(32, 32, 32));
    S.DefineColor("Neutral", Color.DARK_GRAY);
    S.DefineColor("UpSpike", Color.UPTICK);
    S.DefineColor("DownSpike", Color.DOWNTICK);
    S.DefineColor("NeutralSpike", Color.LIGHT_GRAY);
    S.SetDefaultColor(S.Color("Neutral"));
    S.AssignValueColor(
        if isTooEarly or isRecentBar
            then S.Color("Window")
        else if isSpike
            then if data[-BarsAhead] > data
                then S.Color("UpSpike")
            else if data[-BarsAhead] < data
                then S.Color("DownSpike")
                else S.Color("NeutralSpike")
        else
            S.Color("Neutral")
    );

    AssignPriceColor(
        if Display == Display.Lower
            then Color.CURRENT
        else if isSpike
            then GlobalColor("Spike")
        else if isBarAhead
            then Color.CURRENT
        else if isTooEarly or isRecentBar
            then S.Color("Window")
            else S.Color("Neutral")
    );

    # Mid
    plot Mid = 0;
    Mid.SetHiding(Display == Display.Upper);
    Mid.SetDefaultColor(GlobalColor("Line"));
    Mid.HideBubble();
    Mid.HideTitle();

    # Separators
    AddVerticalLine(
        visible = Separators and (isRecentBar != isRecentBar[1] or isTooEarly[1] and !isTooEarly),
        color   = GlobalColor("Separator"),
        text    = ""
    );

    # Labels
    AddLabel(
        visible  = ShowLabel,
        color    = CreateColor(96, 96, 96),
        text     = "FOUND: " + spikeCount,
        location = Location.TOP_RIGHT
    );
###
