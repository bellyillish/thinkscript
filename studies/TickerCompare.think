declare lower;
declare real_size;


### SCRIPTS ###
    script Date {
        def yyyymmdd = GetYYYYMMDD();
        def yyyy     = GetYear();
        def mm       = GetMonth();
        def doy      = GetDay();
        def dom      = GetDayOfMonth(yyyymmdd);
        def dow      = GetDayOfWeek(yyyymmdd);
        def dowj1    = GetDayOfWeek(yyyy * 10000 + 0101);
        def ww       = GetWeek();
        def q        = Ceil(mm / 3);
        def yyyyq    = yyyy * 10 + q;
        def yyyymm   = yyyy * 100 + mm;

        def minus = if yyyy > yyyy[1] and ww >= ww[1] then 1
            else if ww != ww[1] then 0
            else minus[1];

        def yyyyww = (yyyy - minus) * 100 + ww;

        def isAfterOpex    = (dom - 14 - if dow > 5 then dow - 5 else dow + 2) > 0;
        def isEndOfQuarter = mm % 3 == 0;

        def qOpex = if q + isAfterOpex * isEndOfQuarter <= 4
            then q + isAfterOpex * isEndOfQuarter
            else 1;

        def mmOpex = if mm + isAfterOpex <= 12
            then mm + isAfterOpex
            else 1;

        def yyyyOpex = if mm + isAfterOpex <= 12
            then yyyy
            else yyyy + 1;

        def yyyyqOpex  = yyyyOpex * 10  + qOpex;
        def yyyymmOpex = yyyyOpex * 100 + mmOpex;

        plot P = yyyymmdd;
        P.hide();
    }

    script Chart {
        input Validator = "$DJI";

        def aggregation   = GetAggregationPeriod();
        def isIntraday    = aggregation <  AggregationPeriod.DAY;
        def isDaily       = aggregation == AggregationPeriod.DAY;
        def isMultiDay    = aggregation >  AggregationPeriod.DAY;
        def isIntradayBar = isIntraday and Date() == Date()[1];
        def number        = BarNumber();
        def startBar      = First(number);
        def endBar        = HighestAll(number * !IsNaN(close(Validator)));
        def isValidBar    = number between startBar and endBar;
        def startOffset   = number - startBar;
        def endOffset     = number - endBar;
        def isStart       = number == startBar;
        def isEnd         = number == endBar;

        plot P = Double.NaN;
        P.hide();
    }

    script Value {
        input raw    = 0;
        input minRaw = 0;
        input maxRaw = 0;

        def minValue = if minRaw < 0 then minRaw else -999999999999999;
        def maxValue = if maxRaw > 0 then maxRaw else  999999999999999;

        def isValid;
        if IsNaN(raw) or IsInfinite(raw) {
            isValid = no;
        }
        else {
            isValid = raw between minValue and maxValue;
        }

        def value = if isValid or !Chart().isValidBar
            then raw
            else value[1];

        plot P = Double.NaN;
        P.hide();
    }

    script Periods {
        input period  = "Chart";
        input since   = 20250407;
        input candles = 100;

        def isStart     = Chart().isStart;
        def endBar      = Chart().endBar;
        def aggregation = GetAggregationPeriod();

        def isNew;
        if period == "Daily" and aggregation <= AggregationPeriod.FOUR_HOURS {
            isNew = isStart or Date() != Date()[1];
        }
        else if period == "Weekly" and aggregation <= AggregationPeriod.TWO_DAYS {
            isNew = isStart or Date().yyyyww != Date().yyyyww[1];
        }
        else if period == "Monthly" and aggregation <= AggregationPeriod.WEEK {
            isNew = isStart or Date().yyyymm != Date().yyyymm[1];
        }
        else if period == "MonthlyOPEX" and aggregation <= AggregationPeriod.WEEK {
            isNew = isStart or Date().yyyymmOpex != Date().yyyymmOpex[1];
        }
        else if period == "Quarterly" and aggregation <= AggregationPeriod.MONTH {
            isNew = isStart or Date().yyyyq != Date().yyyyq[1];
        }
        else if period == "QuarterlyOPEX" and aggregation <= AggregationPeriod.MONTH{
            isNew = isStart or Date().yyyyqOpex != Date().yyyyqOpex[1];
        }
        else if period == "Yearly" and aggregation <= AggregationPeriod.QUARTER {
            isNew = isStart or Date().yyyy != Date().yyyy[1];
        }
        else if period == "SinceDate" {
            isNew = Date() >= since and (Date()[1] < since or isStart);
        }
        else if period == "CandlesAgo" {
            isNew = isStart and candles > endBar or BarNumber() + candles == endBar;
        }
        else {
            isNew = isStart;
        }

        def isActive = isNew or isActive[1];

        plot P = isNew;
        P.hide();
    }
###


### INPUTS ###
    input TickerOne = "";
    input TickerTwo = "SPY";

    input QuoteOne = {
        default "Close",
        "Open",
        "High",
        "Low",
        "HL2",
        "HLC3",
        "OHLC4",
        "VWAP",
        "RTH",
        "ETH"
    };

    input QuoteTwo = {
        default "Close",
        "Open",
        "High",
        "Low",
        "HL2",
        "HLC3",
        "OHLC4",
        "VWAP",
        "RTH",
        "ETH"
    };

    input Display = {
        default "Summation",
        "Overlay",
        "Cloud",
        "Ratio"
    };

    input Scale = {
        default "Logarithmic",
        "Relative",
        "Absolute"
    };

    input Period = {
        default "Chart",
        "Daily",
        "Weekly",
        "Monthly",
        "MonthlyOPEX",
        "Quarterly",
        "QuarterlyOPEX",
        "Yearly",
        "CandlesAgo",
        "SinceDate"
    };

    @Date input SinceDate = 20250407;
    input CandlesAgo      = 100;
    input Separators      = yes;
    input Sanitize        = no;
    input Oscillation     = 0;
    input Smoothing       = 0;
###


### LOOKUPS ###
    def typeOne;
    switch (QuoteOne) {
        case "Open"  : typeOne = FundamentalType.OPEN;
        case "High"  : typeOne = FundamentalType.HIGH;
        case "Low"   : typeOne = FundamentalType.LOW;
        case "HL2"   : typeOne = FundamentalType.HL2;
        case "HLC3"  : typeOne = FundamentalType.HLC3;
        case "OHLC4" : typeOne = FundamentalType.OHLC4;
        case "VWAP"  : typeOne = FundamentalType.VWAP;
        default      : typeOne = FundamentalType.CLOSE;
    }

    def typeTwo;
    switch (QuoteTwo) {
        case "Open"  : typeTwo = FundamentalType.OPEN;
        case "High"  : typeTwo = FundamentalType.HIGH;
        case "Low"   : typeTwo = FundamentalType.LOW;
        case "HL2"   : typeTwo = FundamentalType.HL2;
        case "HLC3"  : typeTwo = FundamentalType.HLC3;
        case "OHLC4" : typeTwo = FundamentalType.OHLC4;
        case "VWAP"  : typeTwo = FundamentalType.VWAP;
        default      : typeTwo = FundamentalType.CLOSE;
    }

    def rawOpenOne;
    def rawOpenTwo;
    def rawCloseOne;
    def rawCloseTwo;
    if TickerOne != "" {
        rawCloseOne = Fundamental(typeOne, TickerOne);
        rawCloseTwo = Fundamental(typeTwo, TickerTwo);
        rawOpenOne  = open(TickerOne);
        rawOpenTwo  = open(TickerTwo);
    }
    else {
        rawCloseOne = Fundamental(typeOne, GetSymbol());
        rawCloseTwo = Fundamental(typeTwo, TickerTwo);
        rawOpenOne  = open(GetSymbol());
        rawOpenTwo  = open(TickerTwo);
    }

    # Sanitize
    def cleanOpenOne;
    def cleanOpenTwo;
    def cleanCloseOne;
    def cleanCloseTwo;
    if Sanitize {
        cleanOpenOne  = Value(rawOpenOne).value;
        cleanOpenTwo  = Value(rawOpenTwo).value;
        cleanCloseOne = Value(rawCloseOne).value;
        cleanCloseTwo = Value(rawCloseTwo).value;
    }
    else {
        cleanOpenOne  = rawOpenOne;
        cleanOpenTwo  = rawOpenTwo;
        cleanCloseOne = rawCloseOne;
        cleanCloseTwo = rawCloseTwo;
    }

    # Logarithmic
    def dataOpenOne;
    def dataOpenTwo;
    def dataCloseOne;
    def dataCloseTwo;
    if Scale == Scale.Logarithmic {
        dataOpenOne  = Log(cleanOpenOne);
        dataOpenTwo  = Log(cleanOpenTwo);
        dataCloseOne = Log(cleanCloseOne);
        dataCloseTwo = Log(cleanCloseTwo);
    }
    else {
        dataOpenOne  = cleanOpenOne;
        dataOpenTwo  = cleanOpenTwo;
        dataCloseOne = cleanCloseOne;
        dataCloseTwo = cleanCloseTwo;
    }
###


### CALCULATIONS ###
    def isNewPeriod    = Periods(Period, SinceDate, CandlesAgo).isNew;
    def isActivePeriod = Periods(Period, SinceDate, CandlesAgo).isActive;

    # Open one
    def startOne;
    if QuoteOne == QuoteOne.RTH and !Chart().isIntradayBar {
        startOne = dataOpenOne;
    }
    else {
        startOne = dataCloseOne[1];
    }

    # Open two
    def startTwo;
    if QuoteTwo == QuoteTwo.RTH and !Chart().isIntradayBar {
        startTwo = dataOpenTwo;
    }
    else {
        startTwo = dataCloseTwo[1];
    }

    # Close one
    def endOne;
    if QuoteOne == QuoteOne.ETH and Chart().isIntradayBar {
        endOne = dataCloseOne[1];
    }
    else if QuoteOne == QuoteOne.ETH and !Chart().isMultiDay {
        endOne = dataOpenOne;
    }
    else {
        endOne = dataCloseOne;
    }

    # Close two
    def endTwo;
    if QuoteTwo == QuoteTwo.ETH and Chart().isIntradayBar {
        endTwo = dataCloseTwo[1];
    }
    else if QuoteTwo == QuoteTwo.ETH and !Chart().isMultiDay {
        endTwo = dataOpenTwo;
    }
    else {
        endTwo = dataCloseTwo;
    }

    # Change
    def rawChangeOne;
    def rawChangeTwo;
    if Scale == Scale.Relative {
        rawChangeOne = endOne / startOne - 1;
        rawChangeTwo = endTwo / startTwo - 1;
    }
    else {
        rawChangeOne = endOne - startOne;
        rawChangeTwo = endTwo - startTwo;
    }

    # Oscillation
    def oscChangeOne;
    def oscChangeTwo;
    if Oscillation > 1 {
        oscChangeOne = rawChangeOne - Average(rawChangeOne, Oscillation);
        oscChangeTwo = rawChangeTwo - Average(rawChangeTwo, Oscillation);
    }
    else {
        oscChangeOne = rawChangeOne;
        oscChangeTwo = rawChangeTwo;
    }

    # Smoothing
    def changeOne;
    def changeTwo;
    if Smoothing > 1 {
        changeOne = Inertia(oscChangeOne, Smoothing);
        changeTwo = Inertia(oscChangeTwo, Smoothing);
    }
    else {
        changeOne = oscChangeOne;
        changeTwo = oscChangeTwo;
    }

    # Summation one
    def rawSumOne;
    if !Chart().isValidBar or !isActivePeriod or IsNaN(changeOne + changeTwo) {
        rawSumOne = Double.NaN;
    }
    else if isNewPeriod or IsNaN(rawSumOne[1]) {
        rawSumOne = changeOne + (Scale == Scale.Relative);
    }
    else {
        rawSumOne = if Scale == Scale.Relative
            then rawSumOne[1] * (changeOne + 1)
            else rawSumOne[1] + changeOne;
    }

    # Summation two
    def rawSumTwo;
    if !Chart().isValidBar or !isActivePeriod or IsNaN(changeOne + changeTwo) {
        rawSumTwo = Double.NaN;
    }
    else if isNewPeriod or IsNaN(rawSumTwo[1]) {
        rawSumTwo = changeTwo + (Scale == Scale.Relative);
    }
    else {
        rawSumTwo = if Scale == Scale.Relative
            then rawSumTwo[1] * (changeTwo + 1)
            else rawSumTwo[1] + changeTwo;
    }

    # Relative summation
    def change;
    def sumOne;
    def sumTwo;
    def summation;
    if Scale == Scale.Relative {
        change    = (changeOne + 1) / (changeTwo + 1) - 1;
        summation = (rawSumOne + 1) / (rawSumTwo + 1) - 1;
        sumOne    = rawSumOne - 1;
        sumTwo    = rawSumTwo - 1;
    }
    else {
        change    = changeOne - changeTwo;
        summation = rawSumOne - rawSumTwo;
        sumOne    = rawSumOne;
        sumTwo    = rawSumTwo;
    }
###


### PLOTS ###
    DefineGlobalColor("Line",       CreateColor(48, 48, 48));
    DefineGlobalColor("Separator",  CreateColor(32, 32, 32));
    DefineGlobalColor("Background", CreateColor(12, 12, 12));

    # Summation
    plot S = summation;
    S.SetHiding(Display != Display.Summation);
    S.DefineColor("Up", Color.UPTICK);
    S.DefineColor("Down", Color.DOWNTICK);
    S.DefineColor("Neutral", Color.DARK_GRAY);
    S.SetDefaultColor(S.Color("Neutral"));
    S.AssignValueColor(
        if isNewPeriod and isActivePeriod[1]
            then GlobalColor("Background")
        else if change > 0
            then S.Color("Up")
        else if change < 0
            then S.Color("Down")
            else S.Color("Neutral")
    );

    # Difference/ratio
    plot C = change;
    C.SetHiding(Display != Display.Ratio);
    C.SetPaintingStrategy(PaintingStrategy.HISTOGRAM);
    C.DefineColor("Up", Color.UPTICK);
    C.DefineColor("Down", Color.DOWNTICK);
    C.DefineColor("Neutral", Color.DARK_GRAY);
    C.SetDefaultColor(C.Color("Neutral"));
    C.AssignValueColor(
        if change > 0
            then C.Color("Up")
        else if change < 0
            then C.Color("Down")
            else C.Color("Neutral")
    );

    # One
    plot One = sumOne;
    One.SetHiding(Display != Display.Overlay and Display != Display.Cloud);
    One.DefineColor("Value", Color.UPTICK);
    One.SetDefaultColor(One.Color("Value"));
    One.AssignValueColor(
        if isNewPeriod and Display != Display.Cloud
            then GlobalColor("Background")
            else One.Color("Value")
    );

    # Two
    plot Two = sumTwo;
    Two.SetHiding(Display != Display.Overlay and Display != Display.Cloud);
    Two.DefineColor("Value", Color.DOWNTICK);
    Two.SetDefaultColor(Two.Color("Value"));
    Two.AssignValueColor(
        if isNewPeriod and Display != Display.Cloud
            then GlobalColor("Background")
            else Two.Color("Value")
    );

    # Cloud
    def cloudOne = sumOne;
    def cloudTwo = sumTwo;
    AddCloud(
        data1  = if Display == Display.Cloud then cloudOne else Double.NaN,
        data2  = if Display == Display.Cloud then cloudTwo else Double.NaN,
        color1 = One.Color("Value"),
        color2 = Two.Color("Value")
    );

    # Mid
    plot Mid = 0;
    Mid.SetDefaultColor(GlobalColor("Line"));
    Mid.HideBubble();
    Mid.HideTitle();

    # Separators
    AddVerticalLine(
        visible = Separators and isNewPeriod and isActivePeriod[1],
        color   = GlobalColor("Separator"),
        stroke  = Curve.SHORT_DASH,
        text    = ""
    );
###
